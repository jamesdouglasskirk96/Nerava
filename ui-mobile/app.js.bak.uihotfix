const BASE = (localStorage.getItem('NERAVA_URL') || 'http://127.0.0.1:8000').replace(/\/+$/,'');
const USER = localStorage.getItem('NERAVA_USER') || 'demo@nerava.app';

const el = sel => document.querySelector(sel);
const els = sel => Array.from(document.querySelectorAll(sel));

const header    = el('#appHeader');
const banner    = el('#incentiveBanner');
const mapWrap   = el('#mapWrap');
const hubCard   = el('#hubCard');
const fabPlan   = el('#fabPlan');
const tripPanel = el('#tripPanel');

const pages = {
  explore:  el('#page-explore'),
  charge:   el('#page-charge'),
  wallet:   el('#page-wallet'),
  profile:  el('#page-profile'),
};

function showTab(name){
  // toggle page
  Object.entries(pages).forEach(([k,section])=>{
    section.classList.toggle('visible', k === name);
  });
  // explore shows map & banner; others hide map & banner
  const onExplore = (name === 'explore');
  mapWrap.style.display = onExplore ? 'block' : 'none';
  banner.classList.toggle('hidden', !onExplore);
  // tab active
  els('.tabbar .tab').forEach(btn => btn.classList.toggle('active', btn.dataset.target === name));
  // close trip panel when leaving explore
  if (!onExplore) tripPanel.classList.add('hidden');
}
els('.tabbar .tab').forEach(btn=>{
  btn.addEventListener('click', ()=> showTab(btn.dataset.target));
});

// ---- Map & data ----
let map;
function initMap(){
  map = L.map('map',{ zoomControl:false }).setView([30.4021,-97.7265], 14);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);
}

async function json(url, opts={}){
  const r = await fetch(url, { ...opts, headers: { 'Content-Type':'application/json' }});
  if (!r.ok) throw new Error(`${r.status} ${url}`);
  return r.json();
}

async function loadBanner(){
  try{
    const d = await json(`${BASE}/v1/incentives/window`);
    banner.classList.toggle('hidden', !d || !d.active);
    el('#bannerText').textContent = d && d.hint || 'Cheaper charging now';
  }catch{ /* keep default */ }
}

async function loadRecommendation(){
  try{
    const rec = await json(`${BASE}/v1/hubs/recommend?lat=30.4021&lng=-97.7265&radius_km=2&user_id=${encodeURIComponent(USER)}`);
    el('#chipStatus').textContent = (rec.status || 'busy');
    el('#chipTier').textContent   = (rec.tier || 'premium');
    el('#freeSpots').textContent  = `${rec.free_ports ?? 0} free`;
    el('#hubName').textContent    = `${rec.name || 'Nerava Hub'} • ${rec.id || 1}`;
    // center map near rec if we have location
    if (rec.lat && rec.lng){ map.setView([rec.lat, rec.lng], 15); }
  }catch(e){
    // keep seeded defaults
  }
}

// Wallet
async function loadWallet(){
  try{
    const d = await json(`${BASE}/v1/wallet?user_id=${encodeURIComponent(USER)}`);
    const cents = d.balance_cents ?? 0;
    el('#walletTotal').textContent = `+$${(cents/100).toFixed(2)}`;

    // demo-friendly "ways you earned" (if API has none)
    const ways = d.ways || [
      {label:'Off-peak award', amount_cents: 50},
      {label:'Perk reward',    amount_cents: 75},
      {label:'Utility bonus',   amount_cents: 100},
    ];
    const list = el('#walletWays');
    list.innerHTML = '';
    ways.forEach(w=>{
      const li = document.createElement('li');
      li.innerHTML = `<span>${w.label}</span><span>+$${(w.amount_cents/100).toFixed(2)}</span>`;
      list.appendChild(li);
    });
  }catch(e){
    // graceful
  }
}

// Preferences (save + reload rec)
el('#btnSavePrefs').addEventListener('click', async ()=>{
  const prefs = {};
  els('[data-pref]').forEach(chk => prefs[chk.dataset.pref] = chk.checked);
  try{
    await fetch(`${BASE}/v1/users/${encodeURIComponent(USER)}/prefs`,{
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(prefs)
    });
    await loadRecommendation();
    alert('Preferences saved');
  }catch(e){ alert('Failed saving preferences'); }
});
el('#btnNewRec').addEventListener('click', loadRecommendation);

// Trip planner toggle
fabPlan.addEventListener('click', ()=>{
  hubCard.classList.add('hidden');
  tripPanel.classList.remove('hidden');
});
el('#tripBack').addEventListener('click', (e)=>{
  e.preventDefault();
  tripPanel.classList.add('hidden');
  hubCard.classList.remove('hidden');
});

// Directions/Reserve (stubs)
el('#btnDirections').addEventListener('click', ()=> alert('Launching maps...'));
el('#btnReserve').addEventListener('click',   ()=> alert('Reserved (demo)'));

async function init(){
  initMap();
  await loadBanner();
  await loadRecommendation();
  await loadWallet();
  showTab('explore'); // default
}
document.addEventListener('DOMContentLoaded', init);

// ===== Hub Card Title Polish (non-invasive DOM tweak) =====
(() => {
  const HUB_ID_RX = /\bhub_[a-z0-9]+_[a-z0-9]+\b/gi;

  function first(el, sels) {
    for (const s of sels) { const n = el.querySelector(s); if (n) return n; }
    return null;
  }

  function stripIdsIn(el) {
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
    const toFix = [];
    while (walker.nextNode()) {
      if (HUB_ID_RX.test(walker.currentNode.nodeValue)) toFix.push(walker.currentNode);
    }
    toFix.forEach(n => { n.nodeValue = n.nodeValue.replace(HUB_ID_RX, '').replace(/\s{2,}/g,' ').trim(); });
  }

  function polishCard() {
    const card = document.getElementById('hub-card');
    if (!card) return;

    const headerHost = (card.querySelector('.card-title') || card.querySelector('h2') || card);
    // Try to derive a real hub name
    let hubName = (card.querySelector('[data-hub-name], .hub-title')?.textContent || '').trim();
    if (!hubName) {
      const raw = (headerHost.textContent || '').trim();
      hubName = raw.replace(/recommended\s*/i,'').replace(/\bhub\b$/i,'').trim() || 'Nerava Hub';
    }

    if (!card.querySelector('.hub-name')) {
      const header = document.createElement('div');
      header.innerHTML = `
        <div class="hub-subtitle">Recommended</div>
        <div class="hub-name"></div>
      `;
      headerHost.prepend(header);
    }
    const nameEl = card.querySelector('.hub-name');
    if (nameEl) nameEl.textContent = hubName;

    if (!card.querySelector('.meta-line')) {
      const candidates = Array.from(card.querySelectorAll('p, div, span'))
        .filter(n => /free/i.test(n.textContent) && /Nerava Hub/i.test(n.textContent) || /premium|standard|tier/i.test(n.textContent));
      if (candidates[0]) candidates[0].classList.add('meta-line');
    }

    stripIdsIn(card);
  }

  const mo = new MutationObserver(() => polishCard());
  mo.observe(document.body, { subtree: true, childList: true });
  window.addEventListener('load', polishCard);
})();
// NERAVA_HUB_CARD_FIX — robustly hide hub ids and build clean header
(() => {
  const HUB_ID_RX = /\bhub_[a-z0-9]+_[a-z0-9]+\b/gi;

  function stripHubIdsIn(el) {
    // 1) remove any text-node matches
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
    const edits = [];
    while (walker.nextNode()) {
      const node = walker.currentNode;
      if (HUB_ID_RX.test(node.nodeValue)) edits.push(node);
    }
    edits.forEach(n => {
      n.nodeValue = (n.nodeValue || "").replace(HUB_ID_RX, "").replace(/\s{2,}/g, " ").trim();
    });

    // 2) hide elements explicitly carrying hub ids (defensive)
    el.querySelectorAll('[data-hub-id], .hub-id, [id*="hub_"], [class*="hub_"]').forEach(x => {
      const txt = (x.textContent || "").toLowerCase();
      if (HUB_ID_RX.test(txt)) x.remove(); // remove instead of hide to avoid layout gaps
    });
  }

  function first(el, sels) {
    for (const s of sels) { const n = el.querySelector(s); if (n) return n; }
    return null;
  }

  function buildCleanHeader(card) {
    // Choose a host spot for the header
    const headerHost = first(card, ['.card-title','h2','.title','.header','.top']) || card;

    // Derive a hub name (prefer data / explicit title)
    let hubName = (first(card, ['[data-hub-name]','.hub-title'])?.textContent || "").trim();
    if (!hubName) {
      // Try to parse from the first meta-ish line, before any "•"
      const metaLike = first(card, ['.meta-line','p','span','div']);
      const rawHead  = (metaLike?.textContent || headerHost.textContent || "").trim();
      const cut      = rawHead.split('•').map(s => s.trim());
      // Keep a reasonable, human-looking piece
      hubName = cut.find(s => s && !/^(0\s*free|premium|standard|tier|busy|open)$/i.test(s)) || "Nerava Hub";
      hubName = hubName.replace(/^\s*recommended\s*/i,'').replace(/\s*\bhub\b\s*$/i,'').trim() || "Nerava Hub";
    }

    // Inject subtitle + big name once
    if (!card.querySelector('.hub-name')) {
      const wrap = document.createElement('div');
      wrap.innerHTML = `
        <div class="hub-subtitle">Recommended</div>
        <div class="hub-name"></div>
      `;
      headerHost.prepend(wrap);
    }
    const nameEl = card.querySelector('.hub-name');
    if (nameEl) nameEl.textContent = hubName;
  }

  function tagMetaLine(card) {
    if (card.querySelector('.meta-line')) return;
    const candidates = Array.from(card.querySelectorAll('p, div, span'))
      .filter(n => /free/i.test(n.textContent) || /premium|standard|tier/i.test(n.textContent));
    if (candidates[0]) candidates[0].classList.add('meta-line');
  }

  function polishCard() {
    const card = document.getElementById('hub-card');
    if (!card) return;
    buildCleanHeader(card);
    tagMetaLine(card);
    stripHubIdsIn(card);
  }

  // Run on load, after small delay, and on any DOM changes
  window.addEventListener('load', () => {
    polishCard();
    // short burst sweeps in case async render paints late
    let n = 0;
    const t = setInterval(() => { polishCard(); if (++n > 12) clearInterval(t); }, 150);
  });
  const mo = new MutationObserver(polishCard);
  mo.observe(document.documentElement, {childList:true,subtree:true});
})();
// NERAVA_UI_QUICK_PATCH — scrub hub ids + unify buttons
(() => {
  const HUB_ID_RX = /\bhub_[a-z0-9]+_[a-z0-9]+\b/gi;

  // text-node scrub + element removal if a node is just the id
  function scrubIds(root){
    if(!root) return;
    // (1) remove elements that are *only* the id
    root.querySelectorAll('*').forEach(el=>{
      const t=(el.textContent||'').trim();
      if (t && t.replace(HUB_ID_RX,'').trim()==='') {
        el.remove();
      }
    });
    // (2) scrub within text nodes
    const w=document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);
    const edits=[];
    while(w.nextNode()){
      const n=w.currentNode;
      if(HUB_ID_RX.test(n.nodeValue)) edits.push(n);
    }
    edits.forEach(n=>{
      n.nodeValue=(n.nodeValue||'').replace(HUB_ID_RX,'').replace(/\s{2,}/g,' ').trim();
    });
    // (3) clean “ • ” runs that can be left behind
    root.querySelectorAll('.meta-line, p, span, div').forEach(n=>{
      const s=(n.textContent||'').replace(/\s*•\s*(?:•\s*)+/g,' • ').replace(/^\s*•\s*|\s*•\s*$/g,'').trim();
      if(s && s!==n.textContent) n.textContent=s;
    });
  }

  // Make a smaller "Recommended" subtitle and a big hub name
  function ensureHeader(card){
    if(!card) return;
    const headerHost = card.querySelector('.card-title, h2, .title, .header, .top') || card;
    let hubName = (card.querySelector('[data-hub-name], .hub-title')?.textContent||'').trim();
    if(!hubName){
      // Try to infer from any line that contains “Nerava Hub …”
      const meta = card.querySelector('.meta-line, p, span, div');
      const raw = (meta?.textContent || headerHost.textContent || '').trim();
      hubName = raw.split('•').map(s=>s.trim())
        .find(s => s && !/^(0\s*free|free|busy|open|premium|standard|tier)$/i.test(s)) || 'Nerava Hub';
      hubName = hubName.replace(/^\s*recommended\s*/i,'').replace(/\bhub\b$/i,'').trim() || 'Nerava Hub';
    }
    if(!card.querySelector('.hub-name')){
      const wrap=document.createElement('div');
      wrap.innerHTML=`
        <div class="hub-subtitle" style="font-size:14px;font-weight:600;opacity:.85;margin-bottom:4px">Recommended</div>
        <div class="hub-name" style="font-size:26px;line-height:1.1;font-weight:800;letter-spacing:.2px;margin-bottom:6px"></div>
      `;
      headerHost.prepend(wrap);
    }
    const nameEl=card.querySelector('.hub-name');
    if(nameEl) nameEl.textContent=hubName;
  }

  // Collapse Reserve + Directions ⇒ Navigate
  function unifyButtons(card){
    if(!card) return;
    // Find a Directions-like button and make it our single "Navigate"
    const dirBtn=[...card.querySelectorAll('a,button')].find(b=>/direction/i.test(b.textContent||''));
    if(dirBtn){
      dirBtn.textContent='Navigate';
      dirBtn.classList.add('nav-btn');
    }
    // Remove any Reserve buttons to avoid confusion
    [...card.querySelectorAll('a,button')].forEach(b=>{
      if(/reserve/i.test(b.textContent||'')) b.remove();
    });
    // Optional: ensure a container row looks good
    if(dirBtn && !dirBtn.parentElement.classList.contains('cta-row')){
      dirBtn.parentElement.classList.add('cta-row');
    }
  }

  function polish(){
    const card=document.getElementById('hub-card');
    if(!card) return;
    ensureHeader(card);
    scrubIds(card);
    unifyButtons(card);
  }

  // Run now, on load, a short sweep, and on DOM changes
  polish();
  window.addEventListener('load', ()=>{
    polish();
    let n=0; const t=setInterval(()=>{polish(); if(++n>15) clearInterval(t);}, 120);
  });
  const mo=new MutationObserver(polish);
  mo.observe(document.documentElement,{subtree:true,childList:true});
})();
// NERAVA_UI_HOTFIX: unify buttons + scrub hub ids + SW cleanup
(() => {
  const HUB_ID_RX = /\bhub_[a-z0-9]+_[a-z0-9]+\b/gi;

  function scrubIds(root){
    if(!root) return;
    // Remove nodes whose text is only the id
    root.querySelectorAll('*').forEach(el=>{
      const t=(el.textContent||'').trim();
      if (t && t.replace(HUB_ID_RX,'').trim()==='') el.remove();
    });
    // Scrub text nodes
    const w=document.createTreeWalker(root,NodeFilter.SHOW_TEXT,null,false);
    const edits=[];
    while(w.nextNode()){
      const n=w.currentNode;
      if(HUB_ID_RX.test(n.nodeValue)) edits.push(n);
    }
    edits.forEach(n=>{
      n.nodeValue=(n.nodeValue||'').replace(HUB_ID_RX,'').replace(/\s{2,}/g,' ').trim();
    });
    // Clean dangling bullets
    root.querySelectorAll('.meta-line, p, span, div').forEach(n=>{
      const s=(n.textContent||'').replace(/\s*•\s*(?:•\s*)+/g,' • ').replace(/^\s*•\s*|\s*•\s*$/g,'').trim();
      if(s && s!==n.textContent) n.textContent=s;
    });
  }

  function ensureHeader(card){
    if(!card) return;
    const host = card.querySelector('.card-title, h2, .title, .header, .top') || card;
    // Try to get a human hub name
    let name = (card.querySelector('[data-hub-name], .hub-title')?.textContent||'').trim();
    if(!name){
      const meta = card.querySelector('.meta-line, p, span, div');
      const raw  = (meta?.textContent || host.textContent || '').trim();
      name = raw.split('•').map(s=>s.trim())
        .find(s => s && !/^(0\s*free|free|busy|open|premium|standard|tier)$/i.test(s)) || 'Nerava Hub';
      name = name.replace(/^\s*recommended\s*/i,'').replace(/\bhub\b$/i,'').trim() || 'Nerava Hub';
    }
    if(!card.querySelector('.hub-name')){
      const wrap=document.createElement('div');
      wrap.innerHTML = '<div class="hub-subtitle" style="font-size:14px;font-weight:600;opacity:.85;margin-bottom:4px">Recommended</div><div class="hub-name" style="font-size:26px;line-height:1.1;font-weight:800;letter-spacing:.2px;margin-bottom:6px"></div>';
      host.prepend(wrap);
    }
    const el=card.querySelector('.hub-name');
    if(el) el.textContent=name;
  }

  function unifyButtons(card){
    if(!card) return;
    const btns=[...card.querySelectorAll('a,button')];
    const dir = btns.find(b=>/direction/i.test(b.textContent||''));
    // Remove any Reserve button
    btns.forEach(b=>{ if(/reserve/i.test(b.textContent||'')) b.remove(); });
    if(dir){
      dir.textContent='Navigate';
      dir.classList.add('nav-btn');
      if(!dir.parentElement.classList.contains('cta-row')) dir.parentElement.classList.add('cta-row');
    }
  }

  function polish(){
    const card=document.getElementById('hub-card');
    if(card){
      ensureHeader(card);
      unifyButtons(card);
      scrubIds(card);
    }
  }

  // Run now + later (in case async render)
  polish();
  window.addEventListener('load', ()=>{
    polish();
    let i=0; const t=setInterval(()=>{polish(); if(++i>15) clearInterval(t);}, 120);
  });
  new MutationObserver(polish).observe(document.documentElement,{subtree:true,childList:true});

  // Try to evict old service workers (dev convenience)
  if('serviceWorker' in navigator){
    navigator.serviceWorker.getRegistrations().then(rs=>{
      rs.forEach(r=>r.unregister().catch(()=>{}));
    }).catch(()=>{});
  }
})();
