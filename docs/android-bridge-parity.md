# Native Bridge Contract — iOS / Android Parity

This document defines the exact bridge message contract between the React web driver app (`apps/driver/`) and native shell apps. Both iOS and Android MUST implement this contract identically.

**Bridge detection:** The web app checks `window.neravaNative` existence. If present, the bridge is active. The env var `VITE_NATIVE_BRIDGE_ENABLED` must be `true`.

---

## 1. Bridge Injection

At document start, the native app injects a JavaScript object `window.neravaNative` into the WebView. This object provides:

- **`postMessage(action, payload)`** — fire-and-forget command to native
- **`request(action, payload)`** — async query returning a Promise (10s timeout)
- Convenience methods that delegate to `postMessage` or `request`

The native app also injects `window.neravaNativeCallback(action, payload)` which:
1. If `payload.requestId` matches a pending request → resolves the Promise
2. Otherwise → dispatches `CustomEvent('neravaNative', { detail: { action, payload } })`

After injection, the native app dispatches `CustomEvent('neravaNativeReady')` and sends a `NATIVE_READY` message via `neravaNativeCallback`.

---

## 2. Web → Native Messages (Commands)

### Fire-and-Forget (no return value)

| Action | Payload | Purpose |
|--------|---------|---------|
| `SET_CHARGER_TARGET` | `{ chargerId: string, chargerLat: number, chargerLng: number }` | Set up geofence monitoring for a charger |
| `SET_AUTH_TOKEN` | `{ token: string }` | Store auth token in secure native storage |
| `EXCLUSIVE_ACTIVATED` | `{ sessionId: string, merchantId: string, merchantLat: number, merchantLng: number }` | Web confirmed exclusive activation → transition ANCHORED → SESSION_ACTIVE |
| `VISIT_VERIFIED` | `{ sessionId: string, verificationCode: string }` | Web confirmed visit → transition → SESSION_ENDED |
| `END_SESSION` | `{}` | User manually ended session |
| `REQUEST_ALWAYS_LOCATION` | `{}` | Request background location permission |

### Request/Response (returns Promise)

| Action | Request Payload | Response Payload | Purpose |
|--------|----------------|------------------|---------|
| `GET_LOCATION` | `{ requestId }` | `{ requestId, lat, lng, accuracy }` | Get current GPS coordinates |
| `GET_SESSION_STATE` | `{ requestId }` | `{ state: SessionState }` | Get current session state |
| `GET_PERMISSION_STATUS` | `{ requestId }` | `{ requestId, status: string, alwaysGranted: boolean }` | Check location permission status |
| `GET_AUTH_TOKEN` | `{ requestId }` | `{ requestId, hasToken: boolean, token?: string }` | Retrieve auth token from native secure storage |

**Note:** `requestId` is auto-generated by the injection script as `req_{counter}_{timestamp}`.

---

## 3. Native → Web Messages (Events)

| Action | Payload | Purpose |
|--------|---------|---------|
| `NATIVE_READY` | `{}` | Bridge is initialized and ready |
| `SESSION_STATE_CHANGED` | `{ state: SessionState }` | Session state machine transition |
| `SESSION_START_REJECTED` | `{ reason: string }` | Native rejected activation (e.g., `NOT_ANCHORED`) |
| `AUTH_REQUIRED` | `{}` | Token expired or invalid; web should clear tokens |
| `EVENT_EMISSION_FAILED` | `{ event: string, reason: string }` | Backend event emission failed after retries |

---

## 4. Session States

```
IDLE → NEAR_CHARGER → ANCHORED → SESSION_ACTIVE → IN_TRANSIT → AT_MERCHANT → SESSION_ENDED
```

Terminal from any active state: `SESSION_ENDED` (via timeout, user cancel, or completion).

| State | Meaning |
|-------|---------|
| `IDLE` | No session, passive monitoring |
| `NEAR_CHARGER` | Within 400m of targeted charger |
| `ANCHORED` | Dwelled at charger for 120s within 30m, speed < 1.5 m/s |
| `SESSION_ACTIVE` | Exclusive activated, still at charger |
| `IN_TRANSIT` | Left charger heading to merchant (15min grace period) |
| `AT_MERCHANT` | Within 40m of merchant location |
| `SESSION_ENDED` | Session complete or expired |

---

## 5. Backend API Endpoints (called by native only)

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `POST /v1/native/session-events` | POST | Emit session event (requires `session_id`) |
| `POST /v1/native/pre-session-events` | POST | Emit pre-session event (no `session_id`) |
| `GET /v1/native/config` | GET | Fetch runtime config (radii, timeouts) |

### Session Event Payload

```json
{
  "schema_version": "1.0",
  "event_id": "uuid",
  "idempotency_key": "uuid",
  "session_id": "...",
  "event": "entered_merchant_zone",
  "occurred_at": "2026-01-31T12:34:56Z",
  "timestamp": "2026-01-31T12:34:56Z",
  "source": "android_native",
  "app_state": "foreground|background",
  "metadata": { "previous_state": "IN_TRANSIT", "new_state": "AT_MERCHANT" }
}

```

**Android uses `"source": "android_native"`** (iOS uses `"ios_native"`).

### Pre-Session Event Payload

```json
{
  "schema_version": "1.0",
  "event_id": "uuid",
  "idempotency_key": "uuid",
  "event": "charger_targeted",
  "charger_id": "...",
  "occurred_at": "2026-01-31T12:34:56Z",
  "timestamp": "2026-01-31T12:34:56Z",
  "source": "android_native",
  "metadata": {}
}
```

### Retry Policy

- Max 3 attempts with exponential backoff (1s, 2s, 4s) + random jitter
- 429 (rate limit) and 5xx → retry
- 401/403 → propagate as AUTH_REQUIRED to web
- Event ID is the idempotency key (must not change between retries)

---

## 6. Session Config (from `/v1/native/config`)

```json
{
  "chargerIntentRadius_m": 400.0,
  "chargerAnchorRadius_m": 30.0,
  "chargerDwellSeconds": 120,
  "merchantUnlockRadius_m": 40.0,
  "gracePeriodSeconds": 900,
  "hardTimeoutSeconds": 3600,
  "locationAccuracyThreshold_m": 50.0,
  "speedThresholdForDwell_mps": 1.5
}
```

---

## 7. Auth Token Flow

1. User logs in via OTP in web app → web stores `access_token` in localStorage
2. Web calls `SET_AUTH_TOKEN` → native stores in secure storage (iOS: Keychain, Android: EncryptedSharedPreferences)
3. Native includes `Authorization: Bearer {token}` in all API calls
4. On 401/403 → native sends `AUTH_REQUIRED` → web clears localStorage tokens
5. On bridge init → if web has token, push to native; if not, pull from native

---

## 8. Geofence & Location Flow

### iOS
- `CLLocationManager` with `CLCircularRegion` geofences (max 2 active)
- `startMonitoringSignificantLocationChanges()` for background
- DwellDetector: 120s within 30m, speed < 1.5 m/s

### Android (Parity Target)
- `FusedLocationProviderClient` with `GeofencingClient` (max 2 active)
- Foreground service for background location
- DwellDetector: same algorithm (120s, 30m, 1.5 m/s)

### Common
- Charger geofence: entry + exit monitoring
- Merchant geofence: entry only
- FIFO eviction when limit exceeded
- Accuracy threshold: reject locations with accuracy > 50m

---

## 9. Origin Validation

Both platforms MUST validate WebView origin before processing bridge messages.

| Environment | Allowed Origins |
|-------------|----------------|
| Production | `https://app.nerava.network` |
| Debug | Also `http://localhost:5173`, `http://localhost:5174` |

---

## 10. Kill Switch / Graceful Degradation

If the native bridge is unavailable or fails:
- `window.neravaNative` is undefined → `bridgeExists()` returns false
- Web app falls back to `navigator.geolocation` for location
- No geofence monitoring (arrival must be confirmed manually)
- Auth tokens remain in localStorage only
- All UI still works; native features degrade silently
